function module(t,i,e){let n,s;e.export({default:()=>h}),e.link("./path.js",{default(t){n=t}},0),e.link("./polygon.js",{default(t){s=t}},1);class h{constructor(t,[i,e,n,s]=[0,0,960,500]){if(!((n=+n)>=(i=+i)&&(s=+s)>=(e=+e)))throw new Error("invalid bounds");this.delaunay=t,this._circumcenters=new Float64Array(2*t.points.length),this.vectors=new Float64Array(2*t.points.length),this.xmax=n,this.xmin=i,this.ymax=s,this.ymin=e,this._init()}update(){return this.delaunay.update(),this._init(),this}_init(){const{delaunay:{points:t,hull:i,triangles:e},vectors:n}=this,s=this.circumcenters=this._circumcenters.subarray(0,e.length/3*2);for(let u=0,x=0,g=e.length,f,d;u<g;u+=3,x+=2){const i=2*e[u],n=2*e[u+1],h=2*e[u+2],l=t[i],r=t[i+1],o=t[n],c=t[n+1],a=t[h],m=t[h+1],g=o-l,y=c-r,_=a-l,p=m-r,v=g*g+y*y,b=_*_+p*p,w=2*(g*p-y*_);if(w)if(Math.abs(w)<1e-8)f=(l+a)/2,d=(r+m)/2;else{const t=1/w;f=l+(p*v-y*b)*t,d=r+(g*b-_*v)*t}else f=(l+a)/2-1e8*p,d=(r+m)/2+1e8*_;s[x]=f,s[x+1]=d}let h=i[i.length-1],l,r=4*h,o,c=t[2*h],a,m=t[2*h+1];n.fill(0);for(let u=0;u<i.length;++u)l=r,o=c,a=m,r=4*(h=i[u]),c=t[2*h],m=t[2*h+1],n[l+2]=n[r]=a-m,n[l+3]=n[r+1]=c-o}render(t){const i=null==t?t=new n:void 0,{delaunay:{halfedges:e,inedges:s,hull:h},circumcenters:l,vectors:r}=this;if(h.length<=1)return null;for(let n=0,a=e.length;n<a;++n){const i=e[n];if(i<n)continue;const s=2*Math.floor(n/3),h=2*Math.floor(i/3),r=l[s],o=l[s+1],c=l[h],a=l[h+1];this._renderSegment(r,o,c,a,t)}let o,c=h[h.length-1];for(let n=0;n<h.length;++n){o=c,c=h[n];const i=2*Math.floor(s[c]/3),e=l[i],a=l[i+1],m=4*o,u=this._project(e,a,r[m+2],r[m+3]);u&&this._renderSegment(e,a,u[0],u[1],t)}return i&&i.value()}renderBounds(t){const i=null==t?t=new n:void 0;return t.rect(this.xmin,this.ymin,this.xmax-this.xmin,this.ymax-this.ymin),i&&i.value()}renderCell(t,i){const e=null==i?i=new n:void 0,s=this._clip(t);if(null===s)return;i.moveTo(s[0],s[1]);let h=s.length;for(;s[0]===s[h-2]&&s[1]===s[h-1]&&h>1;)h-=2;for(let n=2;n<h;n+=2)s[n]===s[n-2]&&s[n+1]===s[n-1]||i.lineTo(s[n],s[n+1]);return i.closePath(),e&&e.value()}*cellPolygons(){const{delaunay:{points:t}}=this;for(let i=0,e=t.length/2;i<e;++i){const t=this.cellPolygon(i);t&&(yield t)}}cellPolygon(t){const i=new s;return this.renderCell(t,i),i.value()}_renderSegment(t,i,e,n,s){let h;const l=this._regioncode(t,i),r=this._regioncode(e,n);0===l&&0===r?(s.moveTo(t,i),s.lineTo(e,n)):(h=this._clipSegment(t,i,e,n,l,r))&&(s.moveTo(h[0],h[1]),s.lineTo(h[2],h[3]))}contains(t,i,e){return(i=+i)==i&&(e=+e)==e&&this.delaunay._step(t,i,e)===t}*neighbors(t){const i=this._clip(t);if(i)for(const e of this.delaunay.neighbors(t)){const t=this._clip(e);if(t)t:for(let n=0,s=i.length;n<s;n+=2)for(let h=0,l=t.length;h<l;h+=2)if(i[n]==t[h]&&i[n+1]==t[h+1]&&i[(n+2)%s]==t[(h+l-2)%l]&&i[(n+3)%s]==t[(h+l-1)%l]){yield e;break t}}}_cell(t){const{circumcenters:i,delaunay:{inedges:e,halfedges:n,triangles:s}}=this,h=e[t];if(-1===h)return null;const l=[];let r=h;do{const e=Math.floor(r/3);if(l.push(i[2*e],i[2*e+1]),s[r=r%3==2?r-2:r+1]!==t)break;r=n[r]}while(r!==h&&-1!==r);return l}_clip(t){if(0===t&&1===this.delaunay.hull.length)return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];const i=this._cell(t);if(null===i)return null;const{vectors:e}=this,n=4*t;return e[n]||e[n+1]?this._clipInfinite(t,i,e[n],e[n+1],e[n+2],e[n+3]):this._clipFinite(t,i)}_clipFinite(t,i){const e=i.length;let n=null,s,h,l=i[e-2],r=i[e-1],o,c=this._regioncode(l,r),a,m;for(let u=0;u<e;u+=2)if(s=l,h=r,l=i[u],r=i[u+1],o=c,c=this._regioncode(l,r),0===o&&0===c)a=m,m=0,n?n.push(l,r):n=[l,r];else{let i,e,u,x,g;if(0===o){if(null===(i=this._clipSegment(s,h,l,r,o,c)))continue;[e,u,x,g]=i}else{if(null===(i=this._clipSegment(l,r,s,h,c,o)))continue;[x,g,e,u]=i,a=m,m=this._edgecode(e,u),a&&m&&this._edge(t,a,m,n,n.length),n?n.push(e,u):n=[e,u]}a=m,m=this._edgecode(x,g),a&&m&&this._edge(t,a,m,n,n.length),n?n.push(x,g):n=[x,g]}if(n)a=m,m=this._edgecode(n[0],n[1]),a&&m&&this._edge(t,a,m,n,n.length);else if(this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2))return[this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax,this.xmin,this.ymin];return n}_clipSegment(t,i,e,n,s,h){for(;;){if(0===s&&0===h)return[t,i,e,n];if(s&h)return null;let l,r,o=s||h;8&o?(l=t+(e-t)*(this.ymax-i)/(n-i),r=this.ymax):4&o?(l=t+(e-t)*(this.ymin-i)/(n-i),r=this.ymin):2&o?(r=i+(n-i)*(this.xmax-t)/(e-t),l=this.xmax):(r=i+(n-i)*(this.xmin-t)/(e-t),l=this.xmin),s?(t=l,i=r,s=this._regioncode(t,i)):(e=l,n=r,h=this._regioncode(e,n))}}_clipInfinite(t,i,e,n,s,h){let l=Array.from(i),r;if((r=this._project(l[0],l[1],e,n))&&l.unshift(r[0],r[1]),(r=this._project(l[l.length-2],l[l.length-1],s,h))&&l.push(r[0],r[1]),l=this._clipFinite(t,l))for(let o=0,c=l.length,a,m=this._edgecode(l[c-2],l[c-1]);o<c;o+=2)a=m,m=this._edgecode(l[o],l[o+1]),a&&m&&(o=this._edge(t,a,m,l,o),c=l.length);else this.contains(t,(this.xmin+this.xmax)/2,(this.ymin+this.ymax)/2)&&(l=[this.xmin,this.ymin,this.xmax,this.ymin,this.xmax,this.ymax,this.xmin,this.ymax]);return l}_edge(t,i,e,n,s){for(;i!==e;){let e,h;switch(i){case 5:i=4;continue;case 4:i=6,e=this.xmax,h=this.ymin;break;case 6:i=2;continue;case 2:i=10,e=this.xmax,h=this.ymax;break;case 10:i=8;continue;case 8:i=9,e=this.xmin,h=this.ymax;break;case 9:i=1;continue;case 1:i=5,e=this.xmin,h=this.ymin}n[s]===e&&n[s+1]===h||!this.contains(t,e,h)||(n.splice(s,0,e,h),s+=2)}if(n.length>4)for(let h=0;h<n.length;h+=2){const t=(h+2)%n.length,i=(h+4)%n.length;(n[h]===n[t]&&n[t]===n[i]||n[h+1]===n[t+1]&&n[t+1]===n[i+1])&&(n.splice(t,2),h-=2)}return s}_project(t,i,e,n){let s=1/0,h,l,r;if(n<0){if(i<=this.ymin)return null;(h=(this.ymin-i)/n)<s&&(r=this.ymin,l=t+(s=h)*e)}else if(n>0){if(i>=this.ymax)return null;(h=(this.ymax-i)/n)<s&&(r=this.ymax,l=t+(s=h)*e)}if(e>0){if(t>=this.xmax)return null;(h=(this.xmax-t)/e)<s&&(l=this.xmax,r=i+(s=h)*n)}else if(e<0){if(t<=this.xmin)return null;(h=(this.xmin-t)/e)<s&&(l=this.xmin,r=i+(s=h)*n)}return[l,r]}_edgecode(t,i){return(t===this.xmin?1:t===this.xmax?2:0)|(i===this.ymin?4:i===this.ymax?8:0)}_regioncode(t,i){return(t<this.xmin?1:t>this.xmax?2:0)|(i<this.ymin?4:i>this.ymax?8:0)}}}

