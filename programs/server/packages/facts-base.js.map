{"version":3,"sources":["meteor://ðŸ’»app/packages/facts-base/facts_base_server.js","meteor://ðŸ’»app/packages/facts-base/facts_base_common.js"],"names":["module","export","Facts","FACTS_COLLECTION","FACTS_PUBLICATION","link","v","hasOwn","Object","prototype","hasOwnProperty","userIdFilter","userId","Package","autopublish","setUserIdFilter","filter","factsByPackage","activeSubscriptions","_factsByPackage","incrementServerFact","pkg","fact","increment","call","forEach","sub","added","packageFacts","changedField","changed","Meteor","defer","publish","ready","push","keys","onStop","activeSub","is_auto"],"mappings":"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","file":"/packages/facts-base.js","sourcesContent":["import { Facts, FACTS_COLLECTION, FACTS_PUBLICATION } from './facts_base_common';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// This file is only used server-side, so no need to check Meteor.isServer.\n\n// By default, we publish facts to no user if autopublish is off, and to all\n// users if autopublish is on.\nlet userIdFilter = function (userId) {\n  return !!Package.autopublish;\n};\n\n// XXX make this take effect at runtime too?\nFacts.setUserIdFilter = function (filter) {\n  userIdFilter = filter;\n};\n\n// XXX Use a minimongo collection instead and hook up an observeChanges\n// directly to a publish.\nconst factsByPackage = {};\nlet activeSubscriptions = [];\n\n// Make factsByPackage data available to the server environment\nFacts._factsByPackage = factsByPackage;\n\nFacts.incrementServerFact = function (pkg, fact, increment) {\n  if (!hasOwn.call(factsByPackage, pkg)) {\n    factsByPackage[pkg] = {};\n    factsByPackage[pkg][fact] = increment;\n    activeSubscriptions.forEach(function (sub) {\n      sub.added(FACTS_COLLECTION, pkg, factsByPackage[pkg]);\n    });\n    return;\n  }\n\n  const packageFacts = factsByPackage[pkg];\n  if (!hasOwn.call(packageFacts, fact)) {\n    factsByPackage[pkg][fact] = 0;\n  }\n  factsByPackage[pkg][fact] += increment;\n  const changedField = {};\n  changedField[fact] = factsByPackage[pkg][fact];\n  activeSubscriptions.forEach(function (sub) {\n    sub.changed(FACTS_COLLECTION, pkg, changedField);\n  });\n};\n\n// Deferred, because we have an unordered dependency on livedata.\n// XXX is this safe? could somebody try to connect before Meteor.publish is\n// called?\nMeteor.defer(function () {\n  // XXX Also publish facts-by-package.\n  Meteor.publish(FACTS_PUBLICATION, function () {\n    const sub = this;\n    if (!userIdFilter(this.userId)) {\n      sub.ready();\n      return;\n    }\n\n    activeSubscriptions.push(sub);\n    Object.keys(factsByPackage).forEach(function (pkg) {\n      sub.added(FACTS_COLLECTION, pkg, factsByPackage[pkg]);\n    });\n    sub.onStop(function () {\n      activeSubscriptions =\n        activeSubscriptions.filter(activeSub => activeSub !== sub);\n    });\n    sub.ready();\n  }, {is_auto: true});\n});\n\nexport {\n  Facts,\n  FACTS_COLLECTION,\n  FACTS_PUBLICATION,\n};\n","const Facts = {};\nconst FACTS_COLLECTION = 'meteor_Facts_server';\nconst FACTS_PUBLICATION = 'meteor_facts';\n\nexport {\n  Facts,\n  FACTS_COLLECTION,\n  FACTS_PUBLICATION,\n};\n"]}